-- DROP TYPE public.professional_faqs;

CREATE TYPE public.professional_faqs AS (
	id_faq int4 GENERATED BY DEFAULT AS IDENTITY,
	active bool,
	id_professional int4,
	faq text,
	created_at timestamp,
	updated_at timestamp);

-- DROP TYPE public.professional_schedule_reminders;

CREATE TYPE public.professional_schedule_reminders AS (
	id_reminder int4 GENERATED BY DEFAULT AS IDENTITY,
	id_schedule int4,
	reminder timestamp,
	sent bool,
	title varchar(200),
	description text,
	url_reminder varchar(500),
	created_at timestamp,
	updated_at timestamp);

-- DROP TYPE public.schedule_status;

CREATE TYPE public.schedule_status AS ENUM (
	'Agendado',
	'Cancelado',
	'Confirmado',
	'Atendido',
	'Não Compareceu');

-- DROP TYPE public.weekday;

CREATE TYPE public.weekday AS ENUM (
	'Domingo',
	'Segunda',
	'Terça',
	'Quarta',
	'Quinta',
	'Sexta',
	'Sábado');

-- DROP TYPE public."_schedule_status";

CREATE TYPE public."_schedule_status" (
	INPUT = array_in,
	OUTPUT = array_out,
	RECEIVE = array_recv,
	SEND = array_send,
	ANALYZE = array_typanalyze,
	ALIGNMENT = 4,
	STORAGE = any,
	CATEGORY = A,
	ELEMENT = public.schedule_status,
	DELIMITER = ',');

-- DROP TYPE public."_weekday";

CREATE TYPE public."_weekday" (
	INPUT = array_in,
	OUTPUT = array_out,
	RECEIVE = array_recv,
	SEND = array_send,
	ANALYZE = array_typanalyze,
	ALIGNMENT = 4,
	STORAGE = any,
	CATEGORY = A,
	ELEMENT = public.weekday,
	DELIMITER = ',');
	


-- ========================================
-- Tabela: public.leads
-- Descrição: Armazena informações dos leads capturados pelo sistema.
-- Detalhes:
--   - Cada lead representa um potencial cliente que interage via WhatsApp ou outras plataformas.
--   - Campos de contato incluem WhatsApp, Instagram e Email.
--   - A tabela garante a unicidade combinada de `remotejid`, `instance` e `id_account`.
--   - Índices otimizam buscas frequentes por email, Instagram, remotejid e outros campos.
--   - Triggers automatizam a atualização dos campos `created_at` e `updated_at`.
-- Exemplos de Uso:
--   - Inserir um novo lead quando um cliente inicia uma conversa no WhatsApp.
--   - Consultar leads ativos para campanhas de marketing via email.
-- ========================================
CREATE TABLE public.leads (
    id_lead int4 GENERATED BY DEFAULT AS IDENTITY (
        INCREMENT BY 1 
        MINVALUE 1 
        MAXVALUE 2147483647 
        START 1 
        CACHE 1 
        NO CYCLE
    ) NOT NULL, -- Identificador único do lead
    remotejid varchar(60) NOT NULL, -- JID remoto do cliente no WhatsApp
    nome varchar(60) NULL, -- Nome do lead, se disponível
    whatsapp varchar(30) NULL, -- Número de WhatsApp do lead
    instagram varchar(100) NULL, -- Handle do Instagram do lead
    email varchar(100) NULL, -- Email do lead
    id_account int4 NULL, -- Conta associada ao lead
    "instance" varchar(100) NULL, -- Instância associada (e.g., n8n ou outro sistema)
    active bool NULL, -- Indicador se o lead está ativo
    thread_id varchar(60) NULL, -- ID do thread do WhatsApp
    created_at timestamp DEFAULT now() NOT NULL, -- Data de criação do registro
    updated_at timestamp DEFAULT now() NOT NULL, -- Data da última atualização do registro
    CONSTRAINT leads_pkey PRIMARY KEY (id_lead), -- Chave primária da tabela
    CONSTRAINT unique_remotejid_instance_account UNIQUE (remotejid, instance, id_account) -- Garante unicidade combinada de remotejid, instance e id_account
);

-- Índices para otimizar consultas frequentes
CREATE INDEX idx_email ON public.leads USING btree (email);
CREATE INDEX idx_id_lead ON public.leads USING btree (id_lead);
CREATE INDEX idx_instagram ON public.leads USING btree (instagram);
CREATE INDEX idx_leads_active ON public.leads USING btree (active);
CREATE INDEX idx_leads_instance ON public.leads USING btree (instance);
CREATE INDEX idx_leads_remotejid ON public.leads USING btree (remotejid);

-- ========================================
-- Tabela: public.log_configurations
-- Descrição: Configurações de nível de log para cada função do sistema.
-- Detalhes:
--   - Define o nível de log (e.g., DEBUG, INFO, WARN, ERROR) para funções específicas.
--   - Facilita a personalização do detalhamento de logs por módulo ou função.
-- Exemplos de Uso:
--   - Ajustar o nível de log da função `prof_validate_holiday` para DEBUG durante testes.
--   - Definir níveis de log diferentes para funções críticas e auxiliares.
-- ========================================
CREATE TABLE public.log_configurations (
    function_name varchar NOT NULL, -- Nome da função que será configurada
    log_level varchar DEFAULT 'INFO'::character varying NOT NULL, -- Nível de log configurado (INFO por padrão)
    CONSTRAINT log_configurations_pkey PRIMARY KEY (function_name) -- Chave primária baseada no nome da função
);

-- ========================================
-- Tabela: public.log_system_config
-- Descrição: Configurações globais de log para módulos do sistema.
-- Detalhes:
--   - Armazena o nível de log para cada módulo.
--   - Permite ajustes granulares de logging por módulo.
--   - Inclui campos para rastrear criação e atualização das configurações.
-- Exemplos de Uso:
--   - Definir o nível de log do módulo `Gerenciamento de Horários` para WARN.
--   - Atualizar configurações de log durante a manutenção do sistema.
-- ========================================
CREATE TABLE public.log_system_config (
    id_config int4 GENERATED BY DEFAULT AS IDENTITY NOT NULL, -- Identificador único da configuração
    module_name varchar(100) NOT NULL, -- Nome do módulo que será configurado
    log_level varchar(10) DEFAULT 'INFO'::character varying NOT NULL, -- Nível de log configurado (INFO por padrão)
    created_at timestamp DEFAULT now() NOT NULL, -- Data de criação da configuração
    updated_at timestamp DEFAULT now() NOT NULL, -- Data da última atualização da configuração
    CONSTRAINT log_system_config_module_name_key UNIQUE (module_name), -- Garante unicidade do nome do módulo
    CONSTRAINT log_system_config_pkey PRIMARY KEY (id_config) -- Chave primária da tabela
);

-- ========================================
-- Tabela: public.log_system_events
-- Descrição: Armazena eventos de log gerados pelo sistema.
-- Detalhes:
--   - Captura logs detalhados incluindo tipo, mensagem, função e módulo de origem.
--   - `extra_info` permite armazenar dados adicionais em formato JSONB para análises avançadas.
--   - Utilizada para monitoramento, auditoria e depuração do sistema.
-- Exemplos de Uso:
--   - Registrar um erro durante o cálculo de penalidades de cancelamento.
--   - Armazenar informações sobre a criação de lembretes para agendamentos.
-- ========================================
CREATE TABLE public.log_system_events (
    id_log int4 GENERATED BY DEFAULT AS IDENTITY NOT NULL, -- Identificador único do log
    log_type varchar(10) NOT NULL, -- Tipo de log (e.g., DEBUG, INFO, WARN, ERROR)
    message text NOT NULL, -- Mensagem detalhada do evento
    function_name varchar(100) NOT NULL, -- Nome da função que gerou o log
    module_name varchar(100) NOT NULL, -- Nome do módulo que gerou o log
    extra_info jsonb DEFAULT '{}'::jsonb NULL, -- Informações adicionais em formato JSONB
    created_at timestamp DEFAULT now() NOT NULL, -- Data de criação do log
    CONSTRAINT log_system_events_pkey PRIMARY KEY (id_log) -- Chave primária da tabela
);

-- Índices para otimizar buscas por tipo de log, função e módulo
CREATE INDEX idx_log_system_events_log_type ON public.log_system_events(log_type);
CREATE INDEX idx_log_system_events_function_name ON public.log_system_events(function_name);
CREATE INDEX idx_log_system_events_module_name ON public.log_system_events(module_name);
CREATE INDEX idx_log_system_events_created_at ON public.log_system_events(created_at);


-- ========================================
-- Funções do Sistema de Agendamento Inteligente
-- Descrição: Conjunto de funções armazenadas para gerenciar agendamentos, logs, penalidades, lembretes e validações no sistema.
-- Detalhes:
--   - As funções cobrem desde a criação de horários aleatórios, logging avançado, cálculo de penalidades de cancelamento,
--     até a confirmação e cancelamento de agendamentos.
--   - Incluem triggers para automatizar ações após inserções, atualizações ou deleções em tabelas específicas.
--   - Utilizam tipagens personalizadas e retornos em formato JSON para facilitar integrações e respostas via API.
-- ========================================

-- ========================================
-- Função: public.create_random_schedule_times(integer)
-- Descrição: Gera horários de trabalho aleatórios para um profissional específico, um para cada dia da semana.
-- Parâmetros:
--   - p_id_professional: Identificador do profissional para o qual os horários serão criados.
-- Retorno: void
-- Exemplos de Uso:
--   SELECT public.create_random_schedule_times(1);
-- ========================================
CREATE OR REPLACE FUNCTION public.create_random_schedule_times(p_id_professional integer)
 RETURNS void
 LANGUAGE plpgsql
 AS $function$
DECLARE
    v_weekday text;
    v_start_time_01 time;
    v_end_time_01 time;
    v_start_time_02 time;
    v_end_time_02 time;
    v_slot_tolerance integer;
BEGIN
    -- Array de dias da semana
    FOREACH v_weekday IN ARRAY ARRAY['Segunda', 'Terça', 'Quarta', 'Quinta', 'Sexta', 'Sábado', 'Domingo']
    LOOP
        -- Gerar horários aleatórios entre 6h e 20h
        v_start_time_01 := to_char((random() * (14) + 6)::integer || ':' || (floor(random()*60))::integer, 'HH24:MI')::time;
        v_end_time_01 := (v_start_time_01 + interval '4 hours')::time;

        -- Decidir aleatoriamente se haverá segundo intervalo (70% de chance)
        IF random() < 0.7 THEN
            v_start_time_02 := (v_end_time_01 + interval '1 hour')::time;
            v_end_time_02 := (v_start_time_02 + interval '4 hours')::time;
        ELSE
            v_start_time_02 := NULL;
            v_end_time_02 := NULL;
        END IF;

        -- Definir slot_tolerance_minutes aleatório entre 5 e 20
        v_slot_tolerance := floor(random() * 16 + 5)::integer;

        -- Inserir horário de trabalho
        INSERT INTO public.professional_schedule_times (
            id_professional, weekday, start_time_01, end_time_01, 
            start_time_02, end_time_02, slot_tolerance_minutes, active
        ) VALUES (
            p_id_professional,
            v_weekday,
            v_start_time_01,
            v_end_time_01,
            v_start_time_02,
            v_end_time_02,
            v_slot_tolerance,
            TRUE
        );
    END LOOP;

    RAISE NOTICE 'Horários de trabalho aleatórios criados para o profissional ID %.', p_id_professional;
END;
$function$
;

-- ========================================
-- Função: public.log_get_level(character varying)
-- Descrição: Obtém o nível de log configurado para um módulo específico.
-- Parâmetros:
--   - p_module_name: Nome do módulo para o qual o nível de log será recuperado.
-- Retorno: character varying
-- Exemplos de Uso:
--   SELECT public.log_get_level('Gerenciamento de Horários');
-- ========================================
CREATE OR REPLACE FUNCTION public.log_get_level(p_module_name character varying)
 RETURNS character varying
 LANGUAGE plpgsql
 AS $function$
DECLARE
    v_log_level VARCHAR;
BEGIN
    SELECT log_level
    INTO v_log_level
    FROM public.log_system_config
    WHERE module_name = p_module_name;

    RETURN COALESCE(v_log_level, 'INFO');
END;
$function$
;

-- ========================================
-- Função: public.log_should_record(character varying, character varying)
-- Descrição: Determina se um log de determinado tipo deve ser registrado com base no nível atual de log.
-- Parâmetros:
--   - p_log_type: Tipo de log (e.g., DEBUG, INFO, WARN, ERROR).
--   - p_current_level: Nível de log configurado para o módulo/função.
-- Retorno: boolean
-- Exemplos de Uso:
--   SELECT public.log_should_record('ERROR', 'INFO'); -- Retorna TRUE
--   SELECT public.log_should_record('DEBUG', 'INFO'); -- Retorna FALSE
-- ========================================
CREATE OR REPLACE FUNCTION public.log_should_record(p_log_type character varying, p_current_level character varying)
 RETURNS boolean
 LANGUAGE plpgsql
 AS $function$
DECLARE
    level_order JSONB := '{
        "DEBUG": 1,
        "INFO": 2,
        "WARN": 3,
        "ERROR": 4
    }'::JSONB;
BEGIN
    -- Retorna verdadeiro se o nível do log_type for maior ou igual ao current_level
    RETURN (level_order ->> p_log_type)::INT >= (level_order ->> p_current_level)::INT;
END;
$function$
;

-- ========================================
-- Função: public.log_system(character varying, text, character varying, character varying, jsonb)
-- Descrição: Registra eventos de log no sistema com base nas configurações de nível de log.
-- Parâmetros:
--   - p_log_type: Tipo de log (e.g., DEBUG, INFO, WARN, ERROR).
--   - p_message: Mensagem detalhada do evento.
--   - p_function_name: Nome da função que está gerando o log.
--   - p_module_name: Nome do módulo que está gerando o log.
--   - p_extra_info: Informações adicionais em formato JSONB (opcional).
-- Retorno: void
-- Exemplos de Uso:
--   SELECT public.log_system('INFO', 'Agendamento confirmado.', 'prof_confirm_appointment', 'Agendamentos', '{"id_schedule":1}');
-- ========================================
CREATE OR REPLACE FUNCTION public.log_system(
    p_log_type character varying,
    p_message text,
    p_function_name character varying,
    p_module_name character varying,
    p_extra_info jsonb DEFAULT '{}'::jsonb
)
 RETURNS void
 LANGUAGE plpgsql
 AS $function$
DECLARE
    current_level VARCHAR;
BEGIN
    -- Obter o nível configurado para o módulo
    current_level := public.log_get_level(p_module_name);

    -- Verificar se o log deve ser registrado com base no nível configurado
    IF public.log_should_record(p_log_type, current_level) THEN
        -- Registrar o log somente se o nível de log permitir
        INSERT INTO public.log_system_events (
            log_type, message, function_name, module_name, extra_info, created_at
        ) VALUES (
            p_log_type, p_message, p_function_name, p_module_name, p_extra_info, NOW()
        );
    END IF;
END;
$function$
;

-- ========================================
-- Função: public.prof_calculate_cancellation_penalty(integer)
-- Descrição: Calcula a penalidade de cancelamento para um agendamento específico.
-- Parâmetros:
--   - p_id_schedule: Identificador do agendamento.
-- Retorno: json
-- Exemplos de Uso:
--   SELECT public.prof_calculate_cancellation_penalty(1);
-- ========================================
CREATE OR REPLACE FUNCTION public.prof_calculate_cancellation_penalty(p_id_schedule integer)
 RETURNS json
 LANGUAGE plpgsql
 AS $function$
DECLARE
    appointment_price NUMERIC;
    penalty_percentage NUMERIC;
    penalty_amount NUMERIC;
    refund_amount NUMERIC;
    appointment_time TIMESTAMP;
    minimum_cancel_time INTERVAL;
BEGIN
    -- Log de início da função
    PERFORM public.log_system(
        'DEBUG',
        'Iniciando cálculo de penalidade de cancelamento.',
        'prof_calculate_cancellation_penalty',
        'Cancelamentos',
        jsonb_build_object('id_schedule', p_id_schedule)
    );

    -- Obter informações do serviço e agendamento
    SELECT 
        s.price, 
        svc.cancellation_penalty_percentage, 
        (svc.minimum_cancel_time || ' minutes')::INTERVAL, 
        ps."from"
    INTO 
        appointment_price, 
        penalty_percentage, 
        minimum_cancel_time, 
        appointment_time
    FROM public.professional_schedules ps
    JOIN public.professional_services svc ON ps.id_service = svc.id_service
    JOIN public.professional_services s ON svc.id_service = s.id_service
    WHERE ps.id_schedule = p_id_schedule;

    -- Validar se o preço e a penalidade são válidos
    IF appointment_price IS NULL THEN
        PERFORM public.log_system(
            'ERROR',
            'Agendamento inválido ou sem preço associado.',
            'prof_calculate_cancellation_penalty',
            'Cancelamentos',
            jsonb_build_object('id_schedule', p_id_schedule)
        );

        RETURN json_build_object(
            'error', TRUE,
            'message', 'Agendamento inválido ou sem preço associado.'
        );
    END IF;

    -- Verificar se o cancelamento está dentro do prazo sem penalidade
    IF appointment_time - NOW() >= minimum_cancel_time THEN
        PERFORM public.log_system(
            'INFO',
            'Cancelamento dentro do prazo sem penalidade.',
            'prof_calculate_cancellation_penalty',
            'Cancelamentos',
            jsonb_build_object(
                'id_schedule', p_id_schedule,
                'appointment_time', appointment_time,
                'minimum_cancel_time', minimum_cancel_time
            )
        );

        RETURN json_build_object(
            'success', TRUE,
            'message', 'Cancelamento dentro do prazo sem penalidade.',
            'penalty_amount', 0.0,
            'refund_amount', appointment_price,
            'appointment_price', appointment_price
        );
    END IF;

    -- Calcular penalidade
    penalty_amount := appointment_price * (penalty_percentage / 100.0);
    refund_amount := appointment_price - penalty_amount;

    -- Log de sucesso no cálculo da penalidade
    PERFORM public.log_system(
        'INFO',
        'Cancelamento com penalidade aplicada.',
        'prof_calculate_cancellation_penalty',
        'Cancelamentos',
        jsonb_build_object(
            'id_schedule', p_id_schedule,
            'penalty_percentage', penalty_percentage,
            'penalty_amount', penalty_amount,
            'refund_amount', refund_amount,
            'appointment_price', appointment_price
        )
    );

    -- Retornar os resultados
    RETURN json_build_object(
        'success', TRUE,
        'message', 'Cancelamento com penalidade aplicada.',
        'penalty_percentage', penalty_percentage,
        'penalty_amount', penalty_amount,
        'refund_amount', refund_amount,
        'appointment_price', appointment_price
    );
END;
$function$
;

-- ========================================
-- Função: public.prof_calculate_total_service_time(integer, integer)
-- Descrição: Calcula o tempo total necessário para um serviço, incluindo o tempo de preparação.
-- Parâmetros:
--   - p_session_time: Duração da sessão em minutos.
--   - p_preparation_time: Tempo de preparação em minutos.
-- Retorno: interval
-- Exemplos de Uso:
--   SELECT public.prof_calculate_total_service_time(60, 15);
-- ========================================
CREATE OR REPLACE FUNCTION public.prof_calculate_total_service_time(p_session_time integer, p_preparation_time integer)
 RETURNS interval
 LANGUAGE plpgsql
 AS $function$
BEGIN
    RETURN ((p_session_time + p_preparation_time) || ' minutes')::INTERVAL;
END;
$function$
;

-- ========================================
-- Função: public.prof_cancel_schedule_with_penalty(integer, text)
-- Descrição: Cancela um agendamento aplicando penalidades conforme necessário.
-- Parâmetros:
--   - p_id_schedule: Identificador do agendamento a ser cancelado.
--   - p_cancellation_reason: Motivo do cancelamento.
-- Retorno: json
-- Exemplos de Uso:
--   SELECT public.prof_cancel_schedule_with_penalty(1, 'Motivo do cancelamento');
-- ========================================
CREATE OR REPLACE FUNCTION public.prof_cancel_schedule_with_penalty(p_id_schedule integer, p_cancellation_reason text)
 RETURNS json
 LANGUAGE plpgsql
 AS $function$
DECLARE
    current_status public.schedule_status;
    appointment_name VARCHAR(100);
    appointment_time TIMESTAMP;
    penalty_details JSON;
    v_extra_info JSONB;
    v_log JSONB := jsonb_build_object(
        'level', 'INFO',
        'message', 'Cancelamento realizado com sucesso.',
        'module_name', 'prof_cancel_schedule_with_penalty',
        'function_name', 'Agendamentos',
        'extra_info', jsonb_build_object(
            'id_schedule', p_id_schedule,
            'cancellation_reason', p_cancellation_reason,
            'validations', jsonb_build_array()
        )
    );
    v_validations JSONB := '[]'::jsonb;
BEGIN
    /*
        1) Verificar se o agendamento existe
    */
    SELECT ps.status, ps.name, ps."from"
      INTO current_status, appointment_name, appointment_time
      FROM public.professional_schedules ps
     WHERE ps.id_schedule = p_id_schedule;

    IF NOT FOUND THEN
        -- Armazenar validação de erro
        v_validations := v_validations || jsonb_build_object(
            'name', 'schedule_existence',
            'passed', FALSE,
            'error_message', 'Agendamento não encontrado para o ID fornecido.'
        );

        -- Ajustar log final para erro
        v_log := v_log
            || jsonb_build_object('level', 'ERROR')
            || jsonb_build_object('message', 'Agendamento não encontrado para o ID fornecido.');

        -- Adicionar validations ao extra_info
        v_log := jsonb_set(
            v_log,
            '{extra_info,validations}',
            v_validations
        );

        PERFORM public.log_system(
            v_log->>'level',
            v_log->>'message',
            'Agendamentos',
            'prof_cancel_schedule_with_penalty',
            v_log->'extra_info'
        );

        RETURN json_build_object(
            'error', TRUE,
            'message', 'Agendamento com ID ' || p_id_schedule || ' não encontrado.'
        );
    END IF;

    /*
        2) Verificar status para cancelar
    */
    IF current_status != 'Agendado' THEN
        v_validations := v_validations || jsonb_build_object(
            'name', 'status_validation',
            'passed', FALSE,
            'error_message', 'Agendamento não é passível de cancelamento no status atual.'
        );

        -- Ajustar log final para erro
        v_log := v_log
            || jsonb_build_object('level', 'ERROR')
            || jsonb_build_object('message', 'Agendamento não passível de cancelamento. Status atual: ' || current_status);

        -- Adicionar validations ao extra_info
        v_log := jsonb_set(
            v_log,
            '{extra_info,validations}',
            v_validations
        );

        PERFORM public.log_system(
            v_log->>'level',
            v_log->>'message',
            'Agendamentos',
            'prof_cancel_schedule_with_penalty',
            v_log->'extra_info'
        );

        RETURN json_build_object(
            'error', TRUE,
            'message', 'Agendamento com ID ' || p_id_schedule || ' não é passível de cancelamento. Status atual: ' || current_status
        );
    END IF;

    /*
        3) Calcular penalidade de cancelamento
    */
    penalty_details := public.prof_calculate_cancellation_penalty(p_id_schedule);

    IF (penalty_details->>'error')::BOOLEAN THEN
        v_validations := v_validations || jsonb_build_object(
            'name', 'penalty_calculation',
            'passed', FALSE,
            'error_message', 'Erro ao calcular a penalidade de cancelamento.',
            'penalty_details', penalty_details
        );

        -- Ajustar log final para erro
        v_log := v_log
            || jsonb_build_object('level', 'ERROR')
            || jsonb_build_object('message', 'Erro ao calcular a penalidade de cancelamento.');

        -- Adicionar validations ao extra_info
        v_log := jsonb_set(
            v_log,
            '{extra_info,validations}',
            v_validations
        );

        PERFORM public.log_system(
            v_log->>'level',
            v_log->>'message',
            'Agendamentos',
            'prof_cancel_schedule_with_penalty',
            v_log->'extra_info'
        );

        RETURN penalty_details;
    END IF;

    /*
        4) Atualizar status para Cancelado
    */
    UPDATE public.professional_schedules
       SET status = 'Cancelado',
           cancellation_reason = p_cancellation_reason,
           updated_at = NOW()
     WHERE id_schedule = p_id_schedule;

    /*
        5) Montar validações de sucesso (até aqui passou em todas)
    */
    v_validations := v_validations 
        || jsonb_build_object('name', 'schedule_existence', 'passed', TRUE)
        || jsonb_build_object('name', 'status_validation', 'passed', TRUE)
        || jsonb_build_object('name', 'penalty_calculation', 'passed', TRUE);

    -- Incorporar detalhes do agendamento final no extra_info
    v_log := jsonb_set(
        v_log,
        '{extra_info,cancellation_reason}', 
        to_jsonb(p_cancellation_reason)
    );

    v_log := jsonb_set(
        v_log,
        '{extra_info,penalty_details}', 
        penalty_details
    );

    v_log := jsonb_set(
        v_log,
        '{extra_info,appointment}', 
        jsonb_build_object(
            'id_schedule', p_id_schedule,
            'name', appointment_name,
            'time', appointment_time
        )
    );

    -- Atualizar o array de validações (todas passaram)
    v_log := jsonb_set(
        v_log,
        '{extra_info,validations}',
        v_validations
    );

    -- Log final de sucesso
    PERFORM public.log_system(
        v_log->>'level',
        v_log->>'message',
        'Agendamentos',
        'prof_cancel_schedule_with_penalty',
        v_log->'extra_info'
    );

    -- Remover lembretes pendentes
    DELETE FROM public.professional_schedule_reminders 
    WHERE id_schedule = p_id_schedule;

    RETURN json_build_object(
        'success', TRUE,
        'message', 'Agendamento cancelado com sucesso.',
        'cancellation_reason', p_cancellation_reason,
        'penalty_details', penalty_details,
        'appointment', jsonb_build_object(
            'id_schedule', p_id_schedule,
            'name', appointment_name,
            'time', appointment_time
        )
    );
END;
$function$
;

-- ========================================
-- Função: public.prof_confirm_appointment(integer)
-- Descrição: Confirma um agendamento específico, atualizando seu status e removendo lembretes pendentes.
-- Parâmetros:
--   - p_id_schedule: Identificador do agendamento a ser confirmado.
-- Retorno: json
-- Exemplos de Uso:
--   SELECT public.prof_confirm_appointment(1);
-- ========================================
CREATE OR REPLACE FUNCTION public.prof_confirm_appointment(p_id_schedule integer)
 RETURNS json
 LANGUAGE plpgsql
 AS $function$
DECLARE
    v_current_status public.schedule_status;
    v_validations JSONB := '[]'::jsonb;
    v_log JSONB := jsonb_build_object(
        'level', 'INFO',
        'message', 'Agendamento confirmado com sucesso.',
        'module_name', 'prof_confirm_appointment',
        'function_name', 'Agendamentos',
        'extra_info', jsonb_build_object(
            'id_schedule', p_id_schedule,
            'validations', jsonb_build_array()
        )
    );
BEGIN
    -- Remover lembretes pendentes antes de atualizar o agendamento
    DELETE FROM public.professional_schedule_reminders
    WHERE id_schedule = p_id_schedule
      AND sent = FALSE;

    -- Obter status atual do agendamento
    SELECT status
      INTO v_current_status
      FROM public.professional_schedules
     WHERE id_schedule = p_id_schedule;

    IF NOT FOUND THEN
        -- Agendamento não encontrado
        v_validations := v_validations || jsonb_build_object(
            'name', 'schedule_existence',
            'passed', FALSE,
            'error_message', 'Agendamento não encontrado.'
        );

        v_log := v_log
            || jsonb_build_object('level', 'ERROR')
            || jsonb_build_object('message', 'Agendamento não encontrado para confirmar.');

        v_log := jsonb_set(v_log, '{extra_info,validations}', v_validations);

        PERFORM public.log_system(
            v_log->>'level',
            v_log->>'message',
            'Agendamentos',
            'prof_confirm_appointment',
            v_log->'extra_info'
        );

        RETURN json_build_object(
            'error', TRUE,
            'message', 'Agendamento não encontrado.'
        );
    END IF;

    -- Verificar se o status atual permite confirmação
    IF v_current_status NOT IN ('Agendado') THEN
        v_validations := v_validations || jsonb_build_object(
            'name', 'status_validation',
            'passed', FALSE,
            'error_message', 'Não é possível confirmar. Status atual: ' || v_current_status
        );

        v_log := v_log
            || jsonb_build_object('level', 'ERROR')
            || jsonb_build_object('message', 'Não é possível confirmar agendamento nesse status: ' || v_current_status);

        v_log := jsonb_set(v_log, '{extra_info,validations}', v_validations);

        PERFORM public.log_system(
            v_log->>'level',
            v_log->>'message',
            'Agendamentos',
            'prof_confirm_appointment',
            v_log->'extra_info'
        );

        RETURN json_build_object(
            'error', TRUE,
            'message', 'Não é possível confirmar. Status atual: ' || v_current_status
        );
    END IF;

    -- Atualizar status para Confirmado
    UPDATE public.professional_schedules
       SET status = 'Confirmado',
           updated_at = NOW()
     WHERE id_schedule = p_id_schedule;

    -- Validações bem-sucedidas
    v_validations := v_validations 
        || jsonb_build_object('name', 'schedule_existence', 'passed', TRUE)
        || jsonb_build_object('name', 'status_validation', 'passed', TRUE);

    v_log := jsonb_set(v_log, '{extra_info,validations}', v_validations);

    PERFORM public.log_system(
        v_log->>'level',
        v_log->>'message',
        'Agendamentos',
        'prof_confirm_appointment',
        v_log->'extra_info'
    );

    RETURN json_build_object(
        'success', TRUE,
        'message', 'Agendamento confirmado com sucesso.',
        'id_schedule', p_id_schedule
    );
END;
$function$
;

-- ========================================
-- Função: public.prof_create_reminders_for_schedule(integer)
-- Descrição: Cria lembretes para um agendamento específico com base nas configurações de lembrete do profissional.
-- Parâmetros:
--   - p_id_schedule: Identificador do agendamento para o qual os lembretes serão criados.
-- Retorno: void
-- Exemplos de Uso:
--   SELECT public.prof_create_reminders_for_schedule(1);
-- ========================================
CREATE OR REPLACE FUNCTION public.prof_create_reminders_for_schedule(p_id_schedule integer)
 RETURNS void
 LANGUAGE plpgsql
 AS $function$
DECLARE
    v_id_professional INT;
    v_start_time TIMESTAMP;
    v_reminder_interval INTERVAL;
BEGIN
    -- Obter informações do agendamento
    SELECT ps.id_professional, ps."from"
      INTO v_id_professional, v_start_time
      FROM public.professional_schedules ps
     WHERE ps.id_schedule = p_id_schedule;

    IF NOT FOUND THEN
        RAISE EXCEPTION 'Agendamento % não existe', p_id_schedule;
    END IF;

    -- Apagar lembretes antigos para evitar duplicação (caso seja reagendamento)
    DELETE FROM public.professional_schedule_reminders
     WHERE id_schedule = p_id_schedule;

    -- Obter intervalos cadastrados na tabela professional_reminder_config
    FOR v_reminder_interval IN
        SELECT reminder_interval
          FROM public.professional_reminder_config
         WHERE id_professional = v_id_professional
           AND active = TRUE
    LOOP
        -- Somente criar lembretes se o horário de agendamento ainda não tiver passado
        IF v_start_time > NOW() THEN
            INSERT INTO public.professional_schedule_reminders (
                id_schedule,
                reminder,
                sent,
                title,
                description
                -- url_reminder, se desejar preencher
            )
            VALUES (
                p_id_schedule,
                v_start_time - v_reminder_interval,  -- data/hora do lembrete
                FALSE,
                'Lembrete Automático',
                'Gerado via prof_create_reminders_for_schedule'
            );
        END IF;
    END LOOP;
END;
$function$
;

-- ========================================
-- Função: public.prof_create_reminders_for_schedule(integer, timestamp)
-- Descrição: Cria lembretes fixos (e.g., 24 horas e 1 hora antes) para um agendamento específico.
-- Parâmetros:
--   - p_id_schedule: Identificador do agendamento.
--   - p_start_time: Horário de início do agendamento.
-- Retorno: void
-- Exemplos de Uso:
--   SELECT public.prof_create_reminders_for_schedule(1, '2024-12-15 10:00:00');
-- ========================================
CREATE OR REPLACE FUNCTION public.prof_create_reminders_for_schedule(p_id_schedule integer, p_start_time timestamp without time zone)
 RETURNS void
 LANGUAGE plpgsql
 AS $function$
BEGIN
    -- Lembrete 24 horas antes
    INSERT INTO public.professional_schedule_reminders (
        id_schedule,
        reminder,
        sent,
        title,
        description
    ) VALUES (
        p_id_schedule,
        p_start_time - interval '24 hours',
        FALSE,
        'Lembrete Automático',
        'Lembrete 24 horas antes do seu compromisso.'
    );
    INSERT INTO public.log_system_events (
        log_type,
        message,
        function_name,
        module_name,
        extra_info,
        created_at
    ) VALUES (
        'INFO',
        'Lembrete 24 horas criado para agendamento ID ' || p_id_schedule,
        'prof_create_reminders_for_schedule',
        'Agendamentos',
        jsonb_build_object('id_schedule', p_id_schedule, 'reminder_time', p_start_time - interval '24 hours'),
        NOW()
    );

    -- Lembrete 1 hora antes
    INSERT INTO public.professional_schedule_reminders (
        id_schedule,
        reminder,
        sent,
        title,
        description
    ) VALUES (
        p_id_schedule,
        p_start_time - interval '1 hour',
        FALSE,
        'Lembrete Automático',
        'Lembrete 1 hora antes do seu compromisso.'
    );
    INSERT INTO public.log_system_events (
        log_type,
        message,
        function_name,
        module_name,
        extra_info,
        created_at
    ) VALUES (
        'INFO',
        'Lembrete 1 hora criado para agendamento ID ' || p_id_schedule,
        'prof_create_reminders_for_schedule',
        'Agendamentos',
        jsonb_build_object('id_schedule', p_id_schedule, 'reminder_time', p_start_time - interval '1 hour'),
        NOW()
    );

    -- Adicione mais lembretes conforme necessário
END;
$function$
;

-- ========================================
-- Função: public.prof_delete_reminders_on_status_change()
-- Descrição: Trigger function para remover lembretes pendentes quando o status do agendamento muda para 'Cancelado' ou 'Remarcado'.
-- Parâmetros: 
--   - Triggers: Esta função é utilizada por triggers na tabela professional_schedules.
-- Retorno: trigger
-- Exemplos de Uso:
--   CREATE TRIGGER trg_delete_reminders
--       AFTER UPDATE ON public.professional_schedules
--       FOR EACH ROW
--       EXECUTE FUNCTION public.prof_delete_reminders_on_status_change();
-- ========================================
CREATE OR REPLACE FUNCTION public.prof_delete_reminders_on_status_change()
 RETURNS trigger
 LANGUAGE plpgsql
 AS $function$
BEGIN
    IF NEW.status = 'Cancelado'::public.schedule_status OR NEW.status = 'Remarcado'::public.schedule_status THEN
        DELETE FROM public.professional_schedule_reminders
        WHERE id_schedule = NEW.id_schedule;
    END IF;
    RETURN NEW;
END;
$function$
;

-- ========================================
-- Função: public.prof_generate_time_slots(integer, date)
-- Descrição: Gera slots de tempo disponíveis para um profissional em uma data específica com base em sua configuração de horários.
-- Parâmetros:
--   - p_id_professional: Identificador do profissional.
--   - p_date: Data para a qual os slots serão gerados.
-- Retorno: TABLE(slot_start timestamp without time zone, slot_end timestamp without time zone)
-- Exemplos de Uso:
--   SELECT * FROM public.prof_generate_time_slots(1, '2024-12-15');
-- ========================================
CREATE OR REPLACE FUNCTION public.prof_generate_time_slots(p_id_professional integer, p_date date)
 RETURNS TABLE(slot_start timestamp without time zone, slot_end timestamp without time zone)
 LANGUAGE plpgsql
 AS $function$
DECLARE
    start_time_01 TIME;
    end_time_01 TIME;
    start_time_02 TIME;
    end_time_02 TIME;
    session_time INTERVAL;
    slot_tolerance INTERVAL;
    current_start TIMESTAMP;
    day_of_week public.weekday;
BEGIN
    -- Log de início do processo
    PERFORM public.log_system(
        'DEBUG',
        'Iniciando geração de slots de tempo.',
        'prof_generate_time_slots',
        'Gerenciamento de Horários',
        jsonb_build_object(
            'id_professional', p_id_professional,
            'date', p_date
        )
    );

    -- Identificar o dia da semana
    SELECT CASE to_char(p_date, 'FMDay')
        WHEN 'Sunday' THEN 'Domingo'
        WHEN 'Monday' THEN 'Segunda'
        WHEN 'Tuesday' THEN 'Terça'
        WHEN 'Wednesday' THEN 'Quarta'
        WHEN 'Thursday' THEN 'Quinta'
        WHEN 'Friday' THEN 'Sexta'
        WHEN 'Saturday' THEN 'Sábado'
    END::public.weekday
    INTO day_of_week;

    -- Buscar configurações de horários e sessão
    SELECT pst.start_time_01, pst.end_time_01, pst.start_time_02, pst.end_time_02, 
           (s.session_time || ' minutes')::INTERVAL, 
           (pst.slot_tolerance_minutes || ' minutes')::INTERVAL
    INTO start_time_01, end_time_01, start_time_02, end_time_02, 
         session_time, slot_tolerance
    FROM public.professional_schedule_times pst
    JOIN public.professional_services s ON pst.id_professional = s.id_professional
    WHERE pst.id_professional = p_id_professional
      AND pst.weekday = day_of_week;

    -- Validar horários obtidos
    IF start_time_01 IS NULL AND start_time_02 IS NULL THEN
        PERFORM public.log_system(
            'ERROR',
            'Nenhum horário configurado para o profissional neste dia.',
            'prof_generate_time_slots',
            'Gerenciamento de Horários',
            jsonb_build_object(
                'id_professional', p_id_professional,
                'date', p_date,
                'day_of_week', day_of_week
            )
        );
        RETURN;
    END IF;

    -- Gerar slots para o primeiro intervalo
    current_start := p_date + start_time_01;
    WHILE current_start + session_time <= p_date + end_time_01 LOOP
        slot_start := current_start;
        slot_end := current_start + session_time;
        RETURN NEXT;
        current_start := current_start + session_time + slot_tolerance;
    END LOOP;

    -- Gerar slots para o segundo intervalo, se existir
    IF start_time_02 IS NOT NULL THEN
        current_start := p_date + start_time_02;
        WHILE current_start + session_time <= p_date + end_time_02 LOOP
            slot_start := current_start;
            slot_end := current_start + session_time;
            RETURN NEXT;
            current_start := current_start + session_time + slot_tolerance;
        END LOOP;
    END IF;

    -- Log de sucesso
    PERFORM public.log_system(
        'INFO',
        'Geração de slots concluída com sucesso.',
        'prof_generate_time_slots',
        'Gerenciamento de Horários',
        jsonb_build_object(
            'id_professional', p_id_professional,
            'date', p_date,
            'day_of_week', day_of_week
        )
    );
EXCEPTION
    WHEN OTHERS THEN
        -- Log de erro
        PERFORM public.log_system(
            'ERROR',
            'Erro ao gerar slots de tempo.',
            'prof_generate_time_slots',
            'Gerenciamento de Horários',
            jsonb_build_object(
                'id_professional', p_id_professional,
                'date', p_date,
                'error_message', SQLERRM
            )
        );
        RAISE;
END;
$function$
;

-- ========================================
-- Função: public.prof_get_available_slots(integer, timestamp, integer)
-- Descrição: Obtém os slots de tempo disponíveis para um profissional a partir de uma data inicial por um número máximo de dias.
-- Parâmetros:
--   - p_id_professional: Identificador do profissional.
--   - p_start_date: Data inicial para buscar os slots disponíveis (default: NOW()).
--   - max_days_ahead: Número máximo de dias a partir da data inicial para buscar slots (default: 7).
-- Retorno: jsonb
-- Exemplos de Uso:
--   SELECT public.prof_get_available_slots(1, '2024-12-15 00:00:00', 7);
-- ========================================
CREATE OR REPLACE FUNCTION public.prof_get_available_slots(
    p_id_professional integer, 
    p_start_date timestamp without time zone DEFAULT now(), 
    max_days_ahead integer DEFAULT 7
)
 RETURNS jsonb
 LANGUAGE plpgsql
 AS $function$
DECLARE
    available_slots JSONB := '[]'::jsonb;
    day_slots JSONB;
    day_offset INT := 0;
BEGIN
    -- Log de início da busca de horários
    PERFORM public.log_system(
        'DEBUG',
        'Iniciando busca de horários disponíveis.',
        'prof_get_available_slots',
        'Gerenciamento de Horários',
        jsonb_build_object(
            'id_professional', p_id_professional,
            'start_date', p_start_date,
            'max_days_ahead', max_days_ahead
        )
    );

    WHILE day_offset < max_days_ahead LOOP
        SELECT jsonb_agg(
            jsonb_build_object(
                'start_time', to_char(slot_start, 'YYYY-MM-DD HH24:MI:SS'),
                'end_time', to_char(slot_end, 'YYYY-MM-DD HH24:MI:SS')
            )
        )
        INTO day_slots
        FROM public.prof_generate_time_slots(p_id_professional, p_start_date::DATE + day_offset);

        IF day_slots IS NOT NULL THEN
            available_slots := available_slots || jsonb_build_object(
                'date', to_char(p_start_date + day_offset * INTERVAL '1 day', 'YYYY-MM-DD'),
                'slots', day_slots
            );
        END IF;

        day_offset := day_offset + 1;
    END LOOP;

    -- Log de conclusão da busca de horários
    PERFORM public.log_system(
        'INFO',
        'Busca de horários concluída.',
        'prof_get_available_slots',
        'Gerenciamento de Horários',
        jsonb_build_object(
            'id_professional', p_id_professional,
            'available_slots_count', jsonb_array_length(available_slots)
        )
    );

    RETURN jsonb_build_object(
        'message', 'Horários disponíveis encontrados.',
        'available_slots', available_slots
    );
END;
$function$
;

-- ========================================
-- Função: public.prof_get_professional_faqs(integer)
-- Descrição: Obtém as FAQs (Perguntas Frequentes) ativas de um profissional específico.
-- Parâmetros:
--   - p_id_professional: Identificador do profissional.
-- Retorno: SETOF professional_faqs
-- Exemplos de Uso:
--   SELECT * FROM public.prof_get_professional_faqs(1);
-- ========================================
CREATE OR REPLACE FUNCTION public.prof_get_professional_faqs(p_id_professional integer)
 RETURNS SETOF public.professional_faqs
 LANGUAGE plpgsql
 AS $function$
BEGIN
    RETURN QUERY 
    SELECT f.*
    FROM public.professional_faqs f
    JOIN public.professionals p ON f.id_professional = p.id_professional
    WHERE p.active = TRUE 
      AND p.id_professional = p_id_professional 
      AND f.active = TRUE;
END;
$function$
;

-- ========================================
-- Função: public.prof_get_reminders_to_send()
-- Descrição: Obtém os lembretes que devem ser enviados no momento atual.
-- Parâmetros: Nenhum
-- Retorno: SETOF professional_schedule_reminders
-- Exemplos de Uso:
--   SELECT * FROM public.prof_get_reminders_to_send();
-- ========================================
CREATE OR REPLACE FUNCTION public.prof_get_reminders_to_send()
 RETURNS SETOF public.professional_schedule_reminders
 LANGUAGE plpgsql
 AS $function$
BEGIN
    RETURN QUERY
    SELECT r.*
    FROM public.professional_schedule_reminders r
    JOIN public.professional_schedules ps ON r.id_schedule = ps.id_schedule
    WHERE r.sent = FALSE
      AND r.reminder <= NOW()
      AND ps.status IN ('Agendado', 'Confirmado');  -- Ajuste conforme os status ativos
END;
$function$
;

-- ========================================
-- Função: public.prof_mark_as_attended(integer)
-- Descrição: Marca um agendamento como 'Atendido' se estiver confirmado.
-- Parâmetros:
--   - p_id_schedule: Identificador do agendamento a ser marcado.
-- Retorno: json
-- Exemplos de Uso:
--   SELECT public.prof_mark_as_attended(1);
-- ========================================
CREATE OR REPLACE FUNCTION public.prof_mark_as_attended(p_id_schedule integer)
 RETURNS json
 LANGUAGE plpgsql
 AS $function$
DECLARE
    schedule_record public.professional_schedules%ROWTYPE;
    result json;
BEGIN
    -- Verificar a existência do agendamento
    SELECT * INTO schedule_record
    FROM public.professional_schedules
    WHERE id_schedule = p_id_schedule;
    
    IF NOT FOUND THEN
        RETURN json_build_object(
            'error', true,
            'message', 'Agendamento não encontrado ou status não permite marcar como atendido.'
        );
    END IF;
    
    -- Verificar se o status permite marcar como atendido
    IF schedule_record.status <> 'Confirmado' THEN
        RETURN json_build_object(
            'error', true,
            'message', 'Status do agendamento não permite marcar como atendido.'
        );
    END IF;
    
    -- Atualizar o status para 'Atendido'
    UPDATE public.professional_schedules
    SET status = 'Atendido'
    WHERE id_schedule = p_id_schedule;
    
    RETURN json_build_object(
        'error', false,
        'message', 'Agendamento marcado como atendido com sucesso.'
    );
    
EXCEPTION
    WHEN others THEN
        RETURN json_build_object(
            'error', true,
            'message', 'Erro ao marcar como atendido: ' || SQLERRM
        );
END;
$function$
;

-- ========================================
-- Função: public.prof_mark_no_show(integer)
-- Descrição: Marca um agendamento como 'Não Compareceu' se estiver em status apropriado.
-- Parâmetros:
--   - p_id_schedule: Identificador do agendamento a ser marcado.
-- Retorno: void
-- Exemplos de Uso:
--   SELECT public.prof_mark_no_show(1);
-- ========================================
CREATE OR REPLACE FUNCTION public.prof_mark_no_show(p_id_schedule integer)
 RETURNS void
 LANGUAGE plpgsql
 AS $function$
BEGIN
    -- Atualiza o status do agendamento para 'Não Compareceu'
    UPDATE public.professional_schedules
    SET status = 'Não Compareceu',
        updated_at = NOW()
    WHERE id_schedule = p_id_schedule
      AND status IN ('Agendado', 'Confirmado');  -- Verifica se o status atual permite a atualização

    IF NOT FOUND THEN
        RAISE EXCEPTION 'Agendamento % não encontrado ou status não permite marcar como não compareceu.', p_id_schedule;
    END IF;

    -- Remove lembretes pendentes
    DELETE FROM public.professional_schedule_reminders
    WHERE id_schedule = p_id_schedule
      AND sent = FALSE;
END;
$function$
;

-- ========================================
-- Função: public.prof_reschedule_appointment(integer, timestamp, text)
-- Descrição: Reagenda um agendamento para um novo horário após realizar várias validações.
-- Parâmetros:
--   - p_id_schedule: Identificador do agendamento a ser reagendado.
--   - p_new_start_time: Novo horário de início para o agendamento.
--   - p_reason: Motivo do reagendamento (opcional).
-- Retorno: json
-- Exemplos de Uso:
--   SELECT public.prof_reschedule_appointment(1, '2024-12-16 14:00:00', 'Mudança de horário.');
-- ========================================
CREATE OR REPLACE FUNCTION public.prof_reschedule_appointment(
    p_id_schedule integer, 
    p_new_start_time timestamp without time zone, 
    p_reason text DEFAULT NULL::text
)
 RETURNS json
 LANGUAGE plpgsql
 AS $function$
DECLARE
    v_id_professional INT;
    v_id_service INT;
    v_id_lead INT;
    v_current_status VARCHAR;
    v_new_end_time TIMESTAMP;
    v_validations JSONB := '[]'::jsonb;
    v_log JSONB := jsonb_build_object(
        'level', 'INFO',
        'message', 'Reagendamento realizado com sucesso.',
        'module_name', 'prof_reschedule_appointment',
        'function_name', 'Agendamentos',
        'extra_info', jsonb_build_object(
            'id_schedule', p_id_schedule,
            'reason', p_reason,
            'new_start_time', p_new_start_time,
            'validations', jsonb_build_array()
        )
    );
BEGIN
    /*
        1) Obter informações do agendamento
    */
    SELECT ps.id_professional, ps.id_service, ps.id_lead, ps.status
      INTO v_id_professional, v_id_service, v_id_lead, v_current_status
      FROM public.professional_schedules ps
     WHERE ps.id_schedule = p_id_schedule;

    IF NOT FOUND THEN
        v_validations := v_validations || jsonb_build_object(
            'name', 'schedule_existence',
            'passed', FALSE,
            'error_message', 'Agendamento não encontrado.'
        );

        v_log := v_log
            || jsonb_build_object('level', 'ERROR')
            || jsonb_build_object('message', 'Agendamento não encontrado para o ID: ' || p_id_schedule);

        v_log := jsonb_set(v_log, '{extra_info,validations}', v_validations);

        PERFORM public.log_system(
            v_log->>'level',
            v_log->>'message',
            'Agendamentos',
            'prof_reschedule_appointment',
            v_log->'extra_info'
        );

        RETURN json_build_object('error', TRUE, 'message', 'Agendamento não encontrado.');
    END IF;

    /*
        2) Validação de horário no passado
    */
    IF p_new_start_time < NOW() THEN
        v_validations := v_validations || jsonb_build_object(
            'name', 'past_time_validation',
            'passed', FALSE,
            'error_message', 'Novo horário está no passado.',
            'new_start_time', p_new_start_time,
            'current_time', NOW()
        );

        v_log := v_log
            || jsonb_build_object('level', 'ERROR')
            || jsonb_build_object('message', 'Novo horário está no passado.');

        v_log := jsonb_set(v_log, '{extra_info,validations}', v_validations);

        PERFORM public.log_system(
            v_log->>'level',
            v_log->>'message',
            'Agendamentos',
            'prof_reschedule_appointment',
            v_log->'extra_info'
        );

        RETURN json_build_object('error', TRUE, 'message', 'Novo horário está no passado.');
    END IF;

    /*
        3) Validação de feriado
    */
    IF NOT public.prof_validate_holiday(v_id_professional, p_new_start_time::date) THEN
        v_validations := v_validations || jsonb_build_object(
            'name', 'holiday_validation',
            'passed', FALSE,
            'error_message', 'Novo horário coincide com um feriado ativo.'
        );

        v_log := v_log
            || jsonb_build_object('level', 'ERROR')
            || jsonb_build_object('message', 'Novo horário coincide com um feriado ativo.');

        v_log := jsonb_set(v_log, '{extra_info,validations}', v_validations);

        PERFORM public.log_system(
            v_log->>'level',
            v_log->>'message',
            'Agendamentos',
            'prof_reschedule_appointment',
            v_log->'extra_info'
        );

        RETURN json_build_object('error', TRUE, 'message', 'Novo horário coincide com um feriado ativo.');
    END IF;

    /*
        4) Calcular tempo total do serviço
    */
    v_new_end_time := p_new_start_time + public.prof_calculate_total_service_time(
        (SELECT s.session_time FROM public.professional_services s WHERE s.id_service = v_id_service),
        (SELECT s.preparation_time FROM public.professional_services s WHERE s.id_service = v_id_service)
    );

    /*
        5) Validar sobreposição
    */
    IF NOT public.prof_validate_schedule_overlap(v_id_professional, p_new_start_time, v_new_end_time) THEN
        v_validations := v_validations || jsonb_build_object(
            'name', 'overlap_validation',
            'passed', FALSE,
            'error_message', 'Novo horário entra em conflito com outro agendamento.',
            'new_start_time', p_new_start_time,
            'new_end_time', v_new_end_time
        );

        v_log := v_log
            || jsonb_build_object('level', 'ERROR')
            || jsonb_build_object('message', 'Novo horário entra em conflito com outro agendamento.');

        v_log := jsonb_set(v_log, '{extra_info,validations}', v_validations);

        PERFORM public.log_system(
            v_log->>'level',
            v_log->>'message',
            'Agendamentos',
            'prof_reschedule_appointment',
            v_log->'extra_info'
        );

        RETURN json_build_object('error', TRUE, 'message', 'Novo horário entra em conflito com outro agendamento.');
    END IF;

    /*
        6) Validar horário de trabalho
    */
    IF NOT public.prof_validate_within_work_hours(v_id_professional, p_new_start_time, v_new_end_time) THEN
        v_validations := v_validations || jsonb_build_object(
            'name', 'work_hours_validation',
            'passed', FALSE,
            'error_message', 'Novo horário está fora do horário de trabalho permitido.',
            'start_time', p_new_start_time,
            'end_time', v_new_end_time
        );

        v_log := v_log
            || jsonb_build_object('level', 'ERROR')
            || jsonb_build_object('message', 'Novo horário está fora do horário de trabalho permitido.');

        v_log := jsonb_set(v_log, '{extra_info,validations}', v_validations);

        PERFORM public.log_system(
            v_log->>'level',
            v_log->>'message',
            'Agendamentos',
            'prof_reschedule_appointment',
            v_log->'extra_info'
        );

        RETURN json_build_object('error', TRUE, 'message', 'Novo horário está fora do horário de trabalho permitido.');
    END IF;

    /*
        7) Se chegou aqui, todas as validações passaram
           - Atualizar o agendamento
    */
    UPDATE public.professional_schedules
       SET "from" = p_new_start_time,
           "to" = v_new_end_time,
           updated_at = NOW(),
           description = p_reason
     WHERE id_schedule = p_id_schedule;

    -- Marcar todas as validações como passed=true
    v_validations := v_validations 
        || jsonb_build_object('name', 'schedule_existence', 'passed', TRUE)
        || jsonb_build_object('name', 'past_time_validation', 'passed', TRUE)
        || jsonb_build_object('name', 'holiday_validation', 'passed', TRUE)
        || jsonb_build_object('name', 'overlap_validation', 'passed', TRUE)
        || jsonb_build_object('name', 'work_hours_validation', 'passed', TRUE);

    -- Completar extra_info com dados do agendamento recém-reagendado
    v_log := jsonb_set(
        v_log,
        '{extra_info,id_schedule}',
        to_jsonb(p_id_schedule)
    );

    v_log := jsonb_set(
        v_log,
        '{extra_info,end_time}',
        to_jsonb(v_new_end_time)
    );

    v_log := jsonb_set(
        v_log,
        '{extra_info,reason}',
        to_jsonb(p_reason)
    );

    -- Atualizar o array de validações (todas passaram)
    v_log := jsonb_set(
        v_log,
        '{extra_info,validations}',
        v_validations
    );

    -- Log final de sucesso
    PERFORM public.log_system(
        v_log->>'level',
        v_log->>'message',
        'Agendamentos',
        'prof_reschedule_appointment',
        v_log->'extra_info'
    );

    -- Criar novos lembretes para o agendamento reagendado
    PERFORM public.prof_create_reminders_for_schedule(p_id_schedule, p_new_start_time);

    RETURN json_build_object('success', TRUE, 'message', 'Reagendamento realizado com sucesso.');
END;
$function$
;

-- ========================================
-- Função: public.prof_schedule_appointment(integer, integer, integer, timestamp, text)
-- Descrição: Agenda um novo agendamento para um profissional, realizando várias validações antes da inserção.
-- Parâmetros:
--   - p_id_professional: Identificador do profissional.
--   - p_id_service: Identificador do serviço.
--   - p_id_lead: Identificador do cliente (lead).
--   - p_start_time: Horário de início do agendamento.
--   - p_description: Descrição adicional do agendamento.
-- Retorno: json
-- Exemplos de Uso:
--   SELECT public.prof_schedule_appointment(1, 2, 3, '2024-12-15 10:00:00', 'Consulta inicial.');
-- ========================================
CREATE OR REPLACE FUNCTION public.prof_schedule_appointment(
    p_id_professional integer, 
    p_id_service integer, 
    p_id_lead integer, 
    p_start_time timestamp without time zone, 
    p_description text
)
 RETURNS json
 LANGUAGE plpgsql
 AS $function$
DECLARE
    session_time INT;
    preparation_time INT;
    minimum_scheduling_time INT;
    total_service_time INTERVAL;
    proposed_end TIMESTAMP;
    lead_name VARCHAR(100);
    service_name VARCHAR(100);
    service_price NUMERIC;
    appointment_title VARCHAR(200);
    new_id_schedule INT;
    conflict_count INT;

    v_validations JSONB := '[]'::jsonb;
    v_log JSONB := jsonb_build_object(
        'level', 'INFO',
        'message', 'Agendamento realizado com sucesso.',
        'module_name', 'prof_schedule_appointment',
        'function_name', 'Agendamentos',
        'extra_info', jsonb_build_object(
            'start_time', p_start_time,
            'description', p_description,
            'validations', jsonb_build_array()
        )
    );
BEGIN
    /*
        1) Obter detalhes do serviço
    */
    SELECT s.session_time, s.preparation_time, s.minimum_scheduling_time, s.service, s.price
      INTO session_time, preparation_time, minimum_scheduling_time, service_name, service_price
      FROM public.professional_services s
     WHERE s.id_service = p_id_service;

    /*
        2) Obter nome do cliente (lead)
    */
    SELECT l.nome INTO lead_name
      FROM public.leads l
     WHERE l.id_lead = p_id_lead;

    IF lead_name IS NULL THEN
        v_validations := v_validations || jsonb_build_object(
            'name', 'lead_existence',
            'passed', FALSE,
            'error_message', 'Cliente não encontrado para o ID especificado.'
        );
        
        v_log := v_log
            || jsonb_build_object('level', 'ERROR')
            || jsonb_build_object('message', 'Cliente não encontrado para o ID especificado.');

        v_log := jsonb_set(v_log, '{extra_info,validations}', v_validations);
        
        PERFORM public.log_system(
            v_log->>'level',
            v_log->>'message',
            'Agendamentos',
            'prof_schedule_appointment',
            v_log->'extra_info'
        );

        RETURN json_build_object(
            'error', TRUE,
            'message', 'Cliente não encontrado para o ID especificado.'
        );
    END IF;

    /*
        3) Validar se o horário está no passado
    */
    IF NOT public.prof_validate_not_past_time(p_start_time) THEN
        v_validations := v_validations || jsonb_build_object(
            'name', 'past_time_validation',
            'passed', FALSE,
            'error_message', 'Não é permitido agendar para horários no passado.',
            'start_time', p_start_time
        );

        v_log := v_log
            || jsonb_build_object('level', 'ERROR')
            || jsonb_build_object('message', 'Tentativa de agendamento para horário no passado.');

        v_log := jsonb_set(v_log, '{extra_info,validations}', v_validations);

        PERFORM public.log_system(
            v_log->>'level',
            v_log->>'message',
            'Agendamentos',
            'prof_schedule_appointment',
            v_log->'extra_info'
        );

        RETURN json_build_object(
            'error', TRUE,
            'message', 'Não é permitido agendar para horários no passado.'
        );
    END IF;

    /*
        4) Validar antecedência mínima
    */
    IF NOT public.prof_validate_minimum_scheduling_time(p_start_time, minimum_scheduling_time) THEN
        v_validations := v_validations || jsonb_build_object(
            'name', 'minimum_scheduling_time_validation',
            'passed', FALSE,
            'error_message', 'O horário solicitado não respeita o tempo mínimo de antecedência.',
            'start_time', p_start_time,
            'minimum_scheduling_time', minimum_scheduling_time
        );

        v_log := v_log
            || jsonb_build_object('level', 'ERROR')
            || jsonb_build_object('message', 'O horário solicitado não respeita o tempo mínimo de antecedência.');

        v_log := jsonb_set(v_log, '{extra_info,validations}', v_validations);

        PERFORM public.log_system(
            v_log->>'level',
            v_log->>'message',
            'Agendamentos',
            'prof_schedule_appointment',
            v_log->'extra_info'
        );

        RETURN json_build_object(
            'error', TRUE,
            'message', 'O horário solicitado não respeita o tempo mínimo de antecedência.'
        );
    END IF;

    /*
        5) Validar feriado
    */
    IF NOT public.prof_validate_holiday(p_id_professional, p_start_time::date) THEN
        v_validations := v_validations || jsonb_build_object(
            'name', 'holiday_validation',
            'passed', FALSE,
            'error_message', 'O horário solicitado coincide com um feriado em que o profissional não atende.'
        );

        v_log := v_log
            || jsonb_build_object('level', 'ERROR')
            || jsonb_build_object('message', 'O horário solicitado coincide com um feriado em que o profissional não atende.');

        v_log := jsonb_set(v_log, '{extra_info,validations}', v_validations);

        PERFORM public.log_system(
            v_log->>'level',
            v_log->>'message',
            'Agendamentos',
            'prof_schedule_appointment',
            v_log->'extra_info'
        );

        RETURN json_build_object(
            'error', TRUE,
            'message', 'O horário solicitado coincide com um feriado em que o profissional não atende.'
        );
    END IF;

    /*
        6) Calcular tempo total do serviço
    */
    total_service_time := public.prof_calculate_total_service_time(session_time, preparation_time);
    proposed_end := p_start_time + total_service_time;

    /*
        7) Validar sobreposição
    */
    SELECT count(*)
      INTO conflict_count
      FROM public.professional_schedules 
     WHERE "from" < proposed_end
       AND "to" > p_start_time
       AND id_professional = p_id_professional;

    IF conflict_count > 0 THEN
        v_validations := v_validations || jsonb_build_object(
            'name', 'overlap_validation',
            'passed', FALSE,
            'error_message', 'O horário solicitado está indisponível devido a conflitos.',
            'start_time', p_start_time,
            'proposed_end', proposed_end,
            'conflict_count', conflict_count
        );

        v_log := v_log
            || jsonb_build_object('level', 'ERROR')
            || jsonb_build_object('message', 'O horário solicitado está indisponível devido a conflitos com outros agendamentos.');

        v_log := jsonb_set(v_log, '{extra_info,validations}', v_validations);

        PERFORM public.log_system(
            v_log->>'level',
            v_log->>'message',
            'Agendamentos',
            'prof_schedule_appointment',
            v_log->'extra_info'
        );

        RETURN json_build_object(
            'error', TRUE,
            'message', 'O horário solicitado está indisponível devido a conflitos com outros agendamentos.'
        );
    END IF;

    /*
        8) Validar horário de trabalho
    */
    IF NOT public.prof_validate_within_work_hours(p_id_professional, p_start_time, proposed_end) THEN
        v_validations := v_validations || jsonb_build_object(
            'name', 'work_hours_validation',
            'passed', FALSE,
            'error_message', 'O horário solicitado está fora do horário de trabalho permitido.',
            'start_time', p_start_time,
            'proposed_end', proposed_end
        );

        v_log := v_log
            || jsonb_build_object('level', 'ERROR')
            || jsonb_build_object('message', 'O horário solicitado está fora do horário de trabalho permitido.');

        v_log := jsonb_set(v_log, '{extra_info,validations}', v_validations);

        PERFORM public.log_system(
            v_log->>'level',
            v_log->>'message',
            'Agendamentos',
            'prof_schedule_appointment',
            v_log->'extra_info'
        );

        RETURN json_build_object(
            'error', TRUE,
            'message', 'O horário solicitado está fora do horário de trabalho permitido.'
        );
    END IF;

    /*
        9) Se chegou aqui, todas as validações passaram
           - Construir título do agendamento e inserir na tabela
    */
    appointment_title := format('Agendamento de %s para o serviço %s', lead_name, service_name);

    INSERT INTO public.professional_schedules (
        id_professional, id_service, id_lead, status, "from", "to",
        "name", "title", description, price, created_at, updated_at
    )
    VALUES (
        p_id_professional, p_id_service, p_id_lead, 'Agendado',
        p_start_time, proposed_end,
        lead_name, appointment_title, p_description, service_price,
        NOW(), NOW()
    )
    RETURNING id_schedule INTO new_id_schedule;

    -- Marcar todas as validações como passed=true
    v_validations := v_validations 
        || jsonb_build_object('name', 'lead_existence', 'passed', TRUE)
        || jsonb_build_object('name', 'past_time_validation', 'passed', TRUE)
        || jsonb_build_object('name', 'minimum_scheduling_time_validation', 'passed', TRUE)
        || jsonb_build_object('name', 'holiday_validation', 'passed', TRUE)
        || jsonb_build_object('name', 'overlap_validation', 'passed', TRUE)
        || jsonb_build_object('name', 'work_hours_validation', 'passed', TRUE);

    -- Completar extra_info com dados do agendamento recém-criado
    v_log := jsonb_set(
        v_log,
        '{extra_info,id_schedule}',
        to_jsonb(new_id_schedule)
    );

    v_log := jsonb_set(
        v_log,
        '{extra_info,end_time}',
        to_jsonb(proposed_end)
    );

    v_log := jsonb_set(
        v_log,
        '{extra_info,client_name}',
        to_jsonb(lead_name)
    );

    v_log := jsonb_set(
        v_log,
        '{extra_info,appointment_title}',
        to_jsonb(appointment_title)
    );

    v_log := jsonb_set(
        v_log,
        '{extra_info,price}',
        to_jsonb(service_price)
    );

    v_log := jsonb_set(
        v_log,
        '{extra_info,validations}',
        v_validations
    );

    PERFORM public.log_system(
        v_log->>'level',
        v_log->>'message',
        'Agendamentos',
        'prof_schedule_appointment',
        v_log->'extra_info'
    );

    -- Criar lembretes para o novo agendamento
    PERFORM public.prof_create_reminders_for_schedule(new_id_schedule, p_start_time);

    RETURN json_build_object(
        'success', TRUE,
        'message', 'Agendamento realizado com sucesso.',
        'id_schedule', new_id_schedule,
        'start_time', p_start_time,
        'end_time', proposed_end,
        'client_name', lead_name,
        'appointment_title', appointment_title,
        'price', service_price
    );
END;
$function$
;

-- ========================================
-- Função: public.prof_trg_manage_reminders()
-- Descrição: Trigger function para gerenciar lembretes após operações de INSERT, UPDATE ou DELETE na tabela professional_schedules.
-- Parâmetros: 
--   - Triggers: Esta função é utilizada por triggers na tabela professional_schedules.
-- Retorno: trigger
-- Exemplos de Uso:
--   CREATE TRIGGER trg_manage_reminders
--       AFTER INSERT OR UPDATE OR DELETE ON public.professional_schedules
--       FOR EACH ROW
--       EXECUTE FUNCTION public.prof_trg_manage_reminders();
-- ========================================
CREATE OR REPLACE FUNCTION public.prof_trg_manage_reminders()
 RETURNS trigger
 LANGUAGE plpgsql
 AS $function$
BEGIN
    -- Tratar INSERT: Criar lembretes para um novo agendamento
    IF (TG_OP = 'INSERT') THEN
        PERFORM public.prof_create_reminders_for_schedule(NEW.id_schedule);
        RETURN NEW;

    -- Tratar UPDATE: Verificar se houve alteração no horário ou no status
    ELSIF (TG_OP = 'UPDATE') THEN
        -- Verificar se o horário ("from" ou "to") foi alterado
        IF (OLD."from" <> NEW."from" OR OLD."to" <> NEW."to") THEN
            PERFORM public.prof_create_reminders_for_schedule(NEW.id_schedule, NEW."from");
        END IF;

        -- Verificar se o status mudou para 'Atendido' ou 'Não Compareceu'
        IF (OLD.status <> NEW.status) THEN
            IF (NEW.status IN ('Atendido', 'Não Compareceu')) THEN
                -- Remover lembretes pendentes
                DELETE FROM public.professional_schedule_reminders
                WHERE id_schedule = NEW.id_schedule
                  AND sent = FALSE;
            END IF;
        END IF;

        RETURN NEW;

    -- Tratar DELETE: Remover lembretes associados a um agendamento excluído
    ELSIF (TG_OP = 'DELETE') THEN
        DELETE FROM public.professional_schedule_reminders
        WHERE id_schedule = OLD.id_schedule;
        RETURN OLD;
    END IF;
END;
$function$
;

-- ========================================
-- Função: public.prof_validate_holiday(integer, date)
-- Descrição: Valida se uma data específica é um feriado ativo para um profissional.
-- Parâmetros:
--   - p_id_professional: Identificador do profissional.
--   - p_date: Data a ser validada.
-- Retorno: boolean
-- Exemplos de Uso:
--   SELECT public.prof_validate_holiday(1, '2024-12-25');
-- ========================================
CREATE OR REPLACE FUNCTION public.prof_validate_holiday(p_id_professional integer, p_date date)
 RETURNS boolean
 LANGUAGE plpgsql
 AS $function$
DECLARE
    is_holiday BOOLEAN;
    current_level VARCHAR;
BEGIN
    -- Verificar o nível de log configurado para a função 'prof_validate_holiday'
    SELECT log_level INTO current_level
    FROM public.log_configurations
    WHERE function_name = 'prof_validate_holiday';

    -- Se não houver configuração, assume-se 'INFO' por padrão
    IF current_level IS NULL THEN
        current_level := 'INFO';
    END IF;

    -- Validação de entrada
    IF p_date IS NULL THEN
        -- Verificar se o nível de log permite gravar um log de ERROR
        IF public.log_should_record('ERROR', current_level) THEN
            -- Registrar log de erro
            PERFORM public.log_system(
                'ERROR',
                'A data fornecida é inválida ou nula.',
                'prof_validate_holiday',
                'Gerenciamento de Feriados',
                jsonb_build_object('id_professional', p_id_professional, 'date', p_date)
            );
        END IF;
        -- Retornar FALSE diretamente para evitar interrupção
        RETURN FALSE;
    END IF;

    -- Verificar se a data é um feriado ativo
    SELECT EXISTS (
        SELECT 1
        FROM public.professional_holidays ph
        WHERE ph.id_professional = p_id_professional
          AND ph.holiday_date = p_date
          AND ph.active = TRUE
    )
    INTO is_holiday;

    -- Registrar log dependendo do feriado
    IF is_holiday THEN
        -- Verificar se o nível de log permite gravar um log de INFO
        IF public.log_should_record('INFO', current_level) THEN
            PERFORM public.log_system(
                'INFO',
                'Data é um feriado ativo.',
                'prof_validate_holiday',
                'Gerenciamento de Feriados',
                jsonb_build_object('id_professional', p_id_professional, 'date', p_date)
            );
        END IF;
    ELSE
        -- Verificar se o nível de log permite gravar um log de INFO
        IF public.log_should_record('INFO', current_level) THEN
            PERFORM public.log_system(
                'INFO',
                'Data não é um feriado.',
                'prof_validate_holiday',
                'Gerenciamento de Feriados',
                jsonb_build_object('id_professional', p_id_professional, 'date', p_date)
            );
        END IF;
    END IF;

    RETURN NOT is_holiday; -- Retorna TRUE se não for feriado, FALSE caso contrário
END;
$function$
;

-- ========================================
-- Função: public.prof_validate_minimum_scheduling_time(timestamp, integer)
-- Descrição: Valida se o horário de início do agendamento respeita o tempo mínimo de antecedência configurado.
-- Parâmetros:
--   - p_start_time: Horário de início do agendamento.
--   - p_minimum_scheduling_time: Tempo mínimo de antecedência em minutos.
-- Retorno: boolean
-- Exemplos de Uso:
--   SELECT public.prof_validate_minimum_scheduling_time('2024-12-15 10:00:00', 120);
-- ========================================
CREATE OR REPLACE FUNCTION public.prof_validate_minimum_scheduling_time(
    p_start_time timestamp without time zone, 
    p_minimum_scheduling_time integer
)
 RETURNS boolean
 LANGUAGE plpgsql
 AS $function$
BEGIN
    IF p_start_time < (NOW() + (p_minimum_scheduling_time || ' minutes')::INTERVAL) THEN
        RETURN FALSE;
    END IF;
    RETURN TRUE;
END;
$function$
;

-- ========================================
-- Função: public.prof_validate_not_past_time(timestamp)
-- Descrição: Valida se o horário fornecido não está no passado.
-- Parâmetros:
--   - p_time: Horário a ser validado.
-- Retorno: boolean
-- Exemplos de Uso:
--   SELECT public.prof_validate_not_past_time('2024-12-15 10:00:00');
-- ========================================
CREATE OR REPLACE FUNCTION public.prof_validate_not_past_time(p_time timestamp without time zone)
 RETURNS boolean
 LANGUAGE plpgsql
 AS $function$
BEGIN
    RETURN p_time >= NOW();
END;
$function$
;

-- ========================================
-- Função: public.prof_validate_schedule_overlap(integer, timestamp, timestamp)
-- Descrição: Valida se há sobreposição de agendamentos para um profissional em um determinado intervalo de tempo.
-- Parâmetros:
--   - p_id_professional: Identificador do profissional.
--   - p_start_time: Horário de início do novo agendamento.
--   - p_end_time: Horário de término do novo agendamento.
-- Retorno: boolean
-- Exemplos de Uso:
--   SELECT public.prof_validate_schedule_overlap(1, '2024-12-15 10:00:00', '2024-12-15 11:00:00');
-- ========================================
CREATE OR REPLACE FUNCTION public.prof_validate_schedule_overlap(
    p_id_professional integer, 
    p_start_time timestamp without time zone, 
    p_end_time timestamp without time zone
)
 RETURNS boolean
 LANGUAGE plpgsql
 AS $function$
DECLARE
    conflict_count INTEGER;
BEGIN
    -- Validação de horários nulos
    IF p_start_time IS NULL OR p_end_time IS NULL THEN
        PERFORM public.log_system(
            'ERROR',
            'Horários fornecidos são nulos.',
            'prof_validate_schedule_overlap',
            'Gerenciamento de Agendamentos',
            jsonb_build_object(
                'id_professional', p_id_professional,
                'start_time', p_start_time,
                'end_time', p_end_time
            )
        );
        RAISE EXCEPTION 'Horários fornecidos não podem ser nulos.';
    END IF;

    -- Validação de horários inválidos
    IF p_start_time >= p_end_time THEN
        PERFORM public.log_system(
            'ERROR',
            'Horário de início deve ser menor que o horário de fim.',
            'prof_validate_schedule_overlap',
            'Gerenciamento de Agendamentos',
            jsonb_build_object(
                'id_professional', p_id_professional,
                'start_time', p_start_time,
                'end_time', p_end_time
            )
        );
        RAISE EXCEPTION 'Horário de início deve ser menor que o horário de fim.';
    END IF;

    -- Verifica conflitos com agendamentos existentes
    SELECT COUNT(*)
    INTO conflict_count
    FROM public.professional_schedules ps
    WHERE ps.id_professional = p_id_professional
      AND ps.status IN ('Agendado', 'Confirmado')
      AND (
            (p_start_time, p_end_time) OVERLAPS (ps."from", ps."to")
      );

    -- Registro no log sobre o resultado
    IF conflict_count > 0 THEN
        PERFORM public.log_system(
            'INFO',
            'Conflito de horário detectado.',
            'prof_validate_schedule_overlap',
            'Gerenciamento de Agendamentos',
            jsonb_build_object(
                'id_professional', p_id_professional,
                'start_time', p_start_time,
                'end_time', p_end_time,
                'conflict_count', conflict_count
            )
        );
        RETURN FALSE; -- Conflito detectado
    END IF;

    -- Log para caso sem conflitos
    PERFORM public.log_system(
        'INFO',
        'Nenhum conflito de horário detectado.',
        'prof_validate_schedule_overlap',
        'Gerenciamento de Agendamentos',
        jsonb_build_object(
            'id_professional', p_id_professional,
            'start_time', p_start_time,
            'end_time', p_end_time,
            'conflict_count', conflict_count
        )
    );

    RETURN TRUE; -- Sem conflitos
END;
$function$
;

-- ========================================
-- Função: public.prof_validate_within_work_hours(integer, timestamp, timestamp)
-- Descrição: Valida se um agendamento está dentro dos horários de trabalho permitidos para um profissional.
-- Parâmetros:
--   - p_id_professional: Identificador do profissional.
--   - p_start_time: Horário de início do agendamento.
--   - p_end_time: Horário de término do agendamento.
-- Retorno: boolean
-- Exemplos de Uso:
--   SELECT public.prof_validate_within_work_hours(1, '2024-12-15 10:00:00', '2024-12-15 11:00:00');
-- ========================================
CREATE OR REPLACE FUNCTION public.prof_validate_within_work_hours(
    p_id_professional integer, 
    p_start_time timestamp without time zone, 
    p_end_time timestamp without time zone
)
 RETURNS boolean
 LANGUAGE plpgsql
 AS $function$
DECLARE
    v_start_time_01 TIME;
    v_end_time_01 TIME;
    v_start_time_02 TIME;
    v_end_time_02 TIME;
    v_slot_tolerance INTERVAL;
    v_day_of_week public.weekday;
    v_work_start_1 TIMESTAMP;
    v_work_end_1 TIMESTAMP;
    v_work_start_2 TIMESTAMP;
    v_work_end_2 TIMESTAMP;
BEGIN
    -- Log de início da validação
    PERFORM public.log_system(
        'DEBUG',
        'Iniciando validação de horário.',
        'prof_validate_within_work_hours',
        'Agendamentos',
        jsonb_build_object(
            'id_professional', p_id_professional,
            'start_time', p_start_time,
            'end_time', p_end_time
        )
    );

    -- Identificar o dia da semana e converter para o tipo 'weekday'
    SELECT CASE TO_CHAR(p_start_time, 'FMDay')
        WHEN 'Sunday' THEN 'Domingo'
        WHEN 'Monday' THEN 'Segunda'
        WHEN 'Tuesday' THEN 'Terça'
        WHEN 'Wednesday' THEN 'Quarta'
        WHEN 'Thursday' THEN 'Quinta'
        WHEN 'Friday' THEN 'Sexta'
        WHEN 'Saturday' THEN 'Sábado'
    END::public.weekday
    INTO v_day_of_week;

    -- Buscar horários configurados para o profissional no dia identificado
    SELECT pst.start_time_01, pst.end_time_01, pst.start_time_02, pst.end_time_02,
           (pst.slot_tolerance_minutes || ' minutes')::INTERVAL
    INTO v_start_time_01, v_end_time_01, v_start_time_02, v_end_time_02, v_slot_tolerance
    FROM public.professional_schedule_times pst
    WHERE pst.id_professional = p_id_professional
      AND pst.weekday = v_day_of_week;

    -- Validar o primeiro intervalo ajustado
    IF v_start_time_01 IS NOT NULL THEN
        v_work_start_1 := p_start_time::DATE + v_start_time_01 - v_slot_tolerance;
        v_work_end_1 := p_start_time::DATE + v_end_time_01 + v_slot_tolerance;

        IF p_start_time >= v_work_start_1 AND p_end_time <= v_work_end_1 THEN
            PERFORM public.log_system(
                'INFO',
                'Horário validado no primeiro intervalo.',
                'prof_validate_within_work_hours',
                'Agendamentos',
                jsonb_build_object(
                    'interval', jsonb_build_object('start', v_work_start_1, 'end', v_work_end_1)
                )
            );
            RETURN TRUE;
        END IF;
    END IF;

    -- Validar o segundo intervalo ajustado, se existir
    IF v_start_time_02 IS NOT NULL THEN
        v_work_start_2 := p_start_time::DATE + v_start_time_02 - v_slot_tolerance;
        v_work_end_2 := p_start_time::DATE + v_end_time_02 + v_slot_tolerance;

        IF p_start_time >= v_work_start_2 AND p_end_time <= v_work_end_2 THEN
            PERFORM public.log_system(
                'INFO',
                'Horário validado no segundo intervalo.',
                'prof_validate_within_work_hours',
                'Agendamentos',
                jsonb_build_object(
                    'interval', jsonb_build_object('start', v_work_start_2, 'end', v_work_end_2)
                )
            );
            RETURN TRUE;
        END IF;
    END IF;

    -- Log de validação reprovada
    PERFORM public.log_system(
        'ERROR',
        'Horário fora dos intervalos permitidos.',
        'prof_validate_within_work_hours',
        'Agendamentos',
        jsonb_build_object(
            'start_time', p_start_time,
            'end_time', p_end_time,
            'interval_1', jsonb_build_object('start', v_work_start_1, 'end', v_work_end_1),
            'interval_2', jsonb_build_object('start', v_work_start_2, 'end', v_work_end_2)
        )
    );
    RETURN FALSE;
END;
$function$
;


-- ========================================
-- Função: public.log_update_timestamp()
-- Descrição: Atualiza automaticamente o campo 'updated_at' durante inserções e atualizações.
-- Parâmetros: 
--   - Triggers: Esta função é utilizada por triggers em várias tabelas.
-- Retorno: trigger
-- Exemplos de Uso:
--   CREATE TRIGGER trigger_update_timestamp
--       BEFORE UPDATE ON public.some_table
--       FOR EACH ROW
--       EXECUTE FUNCTION public.log_update_timestamp();
-- ========================================
CREATE OR REPLACE FUNCTION public.log_update_timestamp()
 RETURNS trigger
 LANGUAGE plpgsql
 AS $function$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$function$
;


-- ========================================
-- Script para Criar Triggers de Atualização do 'updated_at' em Todas as Tabelas
-- Descrição: Este script percorre todas as tabelas no esquema 'public' que possuem a coluna 'updated_at'
-- e cria triggers que invocam a função 'log_update_timestamp()' antes de cada operação de UPDATE.
-- Detalhes:
--   - A função 'log_update_timestamp()' deve estar previamente definida no esquema 'public'.
--   - Triggers seguem o padrão de nomenclatura: 'trg_<nome_da_tabela>_update_updated_at'.
--   - O script verifica se o trigger já existe para evitar duplicações.
--   - Mensagens de notificação são emitidas para cada trigger criado ou já existente.
-- ========================================

DO $$
DECLARE
    tbl RECORD;
    trg_name TEXT;
    trigger_exists BOOLEAN;
BEGIN
    -- Percorrer todas as tabelas no esquema 'public'
    FOR tbl IN
        SELECT table_name
        FROM information_schema.tables
        WHERE table_schema = 'public'
          AND table_type = 'BASE TABLE'
    LOOP
        -- Verificar se a tabela possui a coluna 'updated_at'
        IF EXISTS (
            SELECT 1
            FROM information_schema.columns
            WHERE table_schema = 'public'
              AND table_name = tbl.table_name
              AND column_name = 'updated_at'
        ) THEN
            -- Definir um nome padrão para o trigger
            trg_name := 'trg_' || tbl.table_name || '_update_updated_at';
    
            -- Verificar se o trigger já existe para evitar duplicações
            SELECT EXISTS (
                SELECT 1
                FROM pg_trigger
                WHERE tgname = trg_name
                  AND tgrelid = tbl.table_name::regclass
            ) INTO trigger_exists;
    
            IF NOT trigger_exists THEN
                -- Criar o trigger para atualizar 'updated_at' antes de cada UPDATE
                EXECUTE format(
                    'CREATE TRIGGER %I
                     BEFORE UPDATE ON public.%I
                     FOR EACH ROW
                     EXECUTE FUNCTION public.log_update_timestamp();',
                    trg_name,
                    tbl.table_name
                );
    
                RAISE NOTICE 'Trigger % criado para a tabela %.', trg_name, tbl.table_name;
            ELSE
                RAISE NOTICE 'Trigger % já existe para a tabela %.', trg_name, tbl.table_name;
            END IF;
        END IF;
    END LOOP;
END;
$$;


select version()